Conteúdos

Prefácio

1. Introdução a programação funcional
	1.1 Computadores e modelagem
	1.2 O que é uma função
	1.3 Figuras e funções
	1.4 Tipos
	1.5 A linguagem de programação Haskell
	1.6 Expressões e avaliações
	1.7 Definições
	1.8 Definição de funções
	1.9 Tipos e programação funcional
	1.10 Cálculos e avaliações
	1.11 A essência da programação Haskell
	1.12 Domínio - específico da linguagem
	1.13 Dois modelos de figuras
	1.14 Testes, propriedades e provas

2. Iniciando com Haskell e GHCI
	2.1 Um primeiro programa em Haskell
	2.2 Usando Haskell na prática
	2.3 Usando o GHCI
	2.4 O Prelude padrão e as bibliotecas Haskell
	2.5 Modulos
	2.6 Um segundo exemplo: figuras
	2.7 Erros e mensagens de erros
3. Tipos básicos e definições
	3.1 Os boleanos: Bool
	3.2 Os inteiros: integer e Int
	3.3 Sobrecarregando
	3.4 Guardas
	3.5 Caracteres e Strings
	3.6 Números de ponto flutuante:Float
	3.7 Sintaxe
4. Desenhando e escrevendo programas
	4.1 Por onde eu começo? Desenhando um programa em Haskell
	4.2 Resolvendo problemas em passos: definições locais
	4.3 Definindo tipos para nós mesmos: tipos enumerados
	4.4 Recursão
	4.5 Recursão primitiva na prática
	4.6 Exercícios extendidos: figuras
	4.7 Formas gerais de recursão
	4.8 testando programas
5. Tipos de dados, tuplas e listas
	5.1 Introduzindo tuplas e listas
	5.2 Tipos tuplas
	5.3 Introduzindo tipos algébricos
	5.4 Nossas aproximações para listas
	5.5 Listas em Haskell
	5.6 Listas por compreensão
	5.7 Uma base de dados de uma biblioteca
6. Programando com listas
	6.1 Funções genéricas: Polimorfismo
	6.2 Listas de funções Haskell no "Prelude"
	6.3 Encontrando seus próprios caminhos em meio as bibliotecas Haskell
	6.4 A figura exemplo: implementação
	6.5 Exercício extendido: implementeção alternativa de figuras
	6.6 Exercício extendido: figuras posicionadas
	6.7 Exercício extendido: cartões e cartões de jogos
7. Definindo funções sobre listas
	7.1 Revisando casamento de padrões
	7.2 Listas e listas padronizadas
	7.3 Recursão primitiva sobre listas
	7.4 Encontrando a definição de recursão primitiva
	7.5 Recursão geral sobre listas
	Exemplo: Processando texto
8. Executando um jogo: I/O (Entrada/Saída) em Haskell
	8.1 Pedra - Papel - Tesoura: estratégia
	8.2 Porque a Entrada/Saída (I/O) é um problema?
	8.3 A Entrada/Saída básica
	8.4 A notação "do"
	8.5 "Loops" e recursão
	8.6 Pedra - Papel - Tesoura: Executando o jogo
9. Racionalizando programas
        9.1 Entendendo definições
        9.2 Testando e provando
        9.3 Expressões definidas, finitas e terminações
        9.4 Um tanto lógico
        9.5 Indução
        9.6 Mais exemplos de provas por indução
        9.7 Generalizando a prova desejada
10. Generalização: Padrões de computação
        10.1 Padrões de computação sobre listas
        10.2 Funções de alta ordem: funções como argumento
        10.3 Funções "foldr" e recursão primitiva
        10.4 Generalizando: funções "split" sobre listas
        10.5 Revisão de estudo de caso
11. Funções de mais alta ordem
        11.1 Operadores: composição de função e aplicação
        11.2 Expressões para funções: abstração lambda
        11.3 Aplicação parcial
        11.4
        11.5 Definindo funções de mais alta ordem
        11.6 Verificação de generalização de funções
12. Desenvolvendo programas de mais alta ordem
        12.1 Revisando a figura exemplo
        12.2 Funções de dados: combinadores estratégicos
        12.3 Funções de dados: reconhecendo expressões regulares
        12.4 Estudo de caso: funções de dados
        12.5 Exemplo: criando um index
        12.6 Desenvolvimento na prática
        12.7 Entendendo programas
13. Sobrecargas, classes de tipos e tipos de checagem
        13.1 Porque sobrecarga?
        13.2 Introduzindo classes
        13.3 Assinaturas e instâncias
        13.4 Um "tour"nas construções de classes Haskell
        13.5 Tipos de checagem e inferência de tipos: uma visão generalizada
        13.6 Tipos de checagem monomórficas
        13.7 Tipos de checagem polimórficas
        13.8 Tipos de checagem e classes 
14. Tipos algébricos
	14.1 Revendo definições de tipos algébricos
	14.2 Tipos algébricos recursivos
	14.3 Tipos algébricos polimórficos
	14.4 Modelando erros de programas
	14.5 Desenhando com tipos de dados algébricos
	14.6 Tipos algébricos e tipos classes
	14.7 Raciocinando sobre tipos algébricos
15. Estudo de caso: códigos Huffman
	15.1 Modelos em Haskell
	15.2 Desenho modular
	15.3 Codificando e decodificando
	15.4 Implementação - I
	15.5 Construindo a árvore de Huffman
	15.6 Desenho
	15.7 Implementação - II

	
