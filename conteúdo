Conteúdos

Prefácio

1. Introdução a programação funcional
	1.1 Computadores e modelagem
	1.2 O que é uma função
	1.3 Figuras e funções
	1.4 Tipos
	1.5 A linguagem de programação Haskell
	1.6 Expressões e avaliações
	1.7 Definições
	1.8 Definição de funções
	1.9 Tipos e programação funcional
	1.10 Cálculos e avaliações
	1.11 A essência da programação Haskell
	1.12 Domínio - específico da linguagem
	1.13 Dois modelos de figuras
	1.14 Testes, propriedades e provas

2. Iniciando com Haskell e GHCI
	2.1 Um primeiro programa em Haskell
	2.2 Usando Haskell na prática
	2.3 Usando o GHCI
	2.4 O Prelude padrão e as bibliotecas Haskell
	2.5 Modulos
	2.6 Um segundo exemplo: figuras
	2.7 Erros e mensagens de erros
3. Tipos básicos e definições
	3.1 Os boleanos: Bool
	3.2 Os inteiros: integer e Int
	3.3 Sobrecarregando
	3.4 Guardas
	3.5 Caracteres e Strings
	3.6 Números de ponto flutuante:Float
	3.7 Sintaxe
4. Desenhando e escrevendo programas
	4.1 Por onde eu começo? Desenhando um programa em Haskell
	4.2 Resolvendo problemas em passos: definições locais
	4.3 Definindo tipos para nós mesmos: tipos enumerados
	4.4 Recursão
	4.5 Recursão primitiva na prática
	4.6 Exercícios extendidos: figuras
	4.7 Formas gerais de recursão
	4.8 testando programas
5. Tipos de dados, tuplas e listas
	5.1 Introduzindo tuplas e listas
	5.2 Tipos tuplas
	5.3 Introduzindo tipos algébricos
	5.4 Nossas aproximações para listas
	5.5 Listas em Haskell
	5.6 Listas por compreensão
	5.7 Uma base de dados de uma biblioteca
6. Programando com listas
	6.1 Funções genéricas: Polimorfismo
	6.2 Listas de funções Haskell no "Prelude"
	6.3 Encontrando seus próprios caminhos em meio as bibliotecas Haskell
	6.4 A figura exemplo: implementação
	6.5 Exercício extendido: implementeção alternativa de figuras
	6.6 Exercício extendido: figuras posicionadas
	6.7 Exercício extendido: cartões e cartões de jogos
7. Definindo funções sobre listas
	7.1 Revisando casamento de padrões
	7.2 Listas e listas padronizadas
	7.3 Recursão primitiva sobre listas
	7.4 Encontrando a definição de recursão primitiva
	7.5 Recursão geral sobre listas
	Exemplo: Processando texto
8. Executando um jogo: I/O (Entrada/Saída) em Haskell
	8.1 Pedra - Papel - Tesoura: estratégia
	8.2 Porque a Entrada/Saída (I/O) é um problema?
	8.3 A Entrada/Saída básica
	8.4 A notação "do"
	8.5 "Loops" e recursão
	8.6 Pedra - Papel - Tesoura: Executando o jogo
9. Racionalizando programas
        9.1 Entendendo definições
        9.2 Testando e provando
        9.3 Expressões definidas, finitas e terminações
        9.4 Um tanto lógico
        9.5 Indução
        9.6 Mais exemplos de provas por indução
        9.7 Generalizando a prova desejada
10. Generalização: Padrões de computação
        10.1 Padrões de computação sobre listas
        10.2 Funções de alta ordem: funções como argumento
        10.3 Funções "foldr" e recursão primitiva
        10.4 Generalizando: funções "split" sobre listas
        10.5 Revisão de estudo de caso
11. Funções de mais alta ordem
        11.1 Operadores: composição de função e aplicação
        11.2 Expressões para funções: abstração lambda
        11.3 Aplicação parcial
        11.4
        11.5 Definindo funções de mais alta ordem
        11.6 Verificação de generalização de funções
12. Desenvolvendo programas de mais alta ordem
        12.1 Revisando a figura exemplo
        12.2 Funções de dados: combinadores estratégicos
        12.3 Funções de dados: reconhecendo expressões regulares
        12.4 Estudo de caso: funções de dados
        12.5 Exemplo: criando um index
        12.6 Desenvolvimento na prática
        12.7 Entendendo programas
13. Sobrecargas, classes de tipos e tipos de checagem
        13.1 Porque sobrecarga?
        13.2 Introduzindo classes
        13.3 Assinaturas e instâncias
        13.4 Um "tour"nas construções de classes Haskell
        13.5 Tipos de checagem e inferência de tipos: uma visão generalizada
        13.6 Tipos de checagem monomórficas
        13.7 Tipos de checagem polimórficas
        13.8 Tipos de checagem e classes 
14. Tipos algébricos
	14.1 Revendo definições de tipos algébricos
	14.2 Tipos algébricos recursivos
	14.3 Tipos algébricos polimórficos
	14.4 Modelando erros de programas
	14.5 Desenhando com tipos de dados algébricos
	14.6 Tipos algébricos e tipos classes
	14.7 Raciocinando sobre tipos algébricos
15. Estudo de caso: códigos Huffman
	15.1 Modelos em Haskell
	15.2 Desenho modular
	15.3 Codificando e decodificando
	15.4 Implementação - I
	15.5 Construindo a árvore de Huffman
	15.6 Desenho
	15.7 Implementação - II
16. Tipo de dados abstrato
	16.1 Tipo de representação
	16.2 O mecanismo de tipo de dados abstrato em Haskell
	16.3 Filas
	16.4 Desenho
	16.5 Simulação
	16.6 Implementação e simulação
	16.7 Pequisando árvores
	16.8 Conjuntos
	16.9 Relações e gráficos
	16.10 Comentários
17. Programação preguiçosa
	17.1 Evolução preguiçosa
	17.2 Regras de cálculo e evolução preguiçosa
	17.3 Revendo compreensão de listas
	17.4 Programação de dados direcionados
	17.5 Estudo de caso: expressões de análise
	17.6 Limite infinito
	17.7 Por que listas infinitas
	17.8 Estudo de caso: simulação
	17.9 Revendo provas
18. Programação com Monads
	18.1 Programação I/O - input/output - Entrada/Saída
	18.2 Mais I/O
	18.3 A calculadora
	18.4 Revendo a notação "do"
	18.5 Monads: Linguagem para programação funcional
	18.6 Exemplos: Computação monádica sobre árvores
19. Domínio - Linguagem específica -> DSLs
	19.1 Linguagem de programação em qualquer lugar
	19.2 Por que "DSLs" em Haskell ?
	19.3 Embarques rasos e profundos
	19.4 Uma "DSL" para expressões regulares
	19.5 "DSLs" monáqdicas
	19.6 "DSLs" para computação: generalizando dados com QuickChecks
	19.7 Indo mais longe
20. Comportamento do tempo e espaço
	20.1 Funções complexas
	20.2 A complexidade de cálculo
	20.3 Implementação de conjuntos
	20.4 Comportamento espacial
	20.5 Revendo "Folding"
	20.6 Evitando reprocessamento: memorização
21. Conclusão

Apêndices
A. Programação Funcional, Imperativa e Orientada a Objetos
B. Glossário
C. Operadores Haskell
D. Práticas em Haskell
E. "errors" no GHCi
F. Idéias de projetos

Bibliografia

	
